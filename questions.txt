0.  It is the longest word in our dictionary.  It is 45 chars.
1.  It returns resource usage measures for the first argument passed into it.  If RUSAGE_SELF is passed in, it returns resource usage statistics for the calling process, which is the sum of resources used by all threads in the process.
2.  16
3.  Becuase the signature of getrusage calls for reference, not a value.
4.  It starts by getting the first character via fgetc.  Then checks for end of file as a stopping condition; it incrementes to the next char each loop through. The first if statement uses isalpha to verify it is a proper letter; secondarily it checks non-alpha chars to allow only apostrophies through this gate. If these checks pass, the char is added to the word array at index position (intialized at zero outside of the loop) and then increments index. Now it checks the value of index against the constant LENGTH (defined as 45 in dictionary.h). If index is great than 45, it kicks off a while loop that keeps calling the char as long as it has not reached the end of file and is an alpha char; index is reset to 0. If the first if was false then it has a second if that checks for numeric chars. If numerica is uses the same logic in the previously mentioned while loop (changing condition to check for numeric instead of aplha) to move to the end of the numeric string. The final if check will be reached if the char is not alpha or numberic; it checks that there is at least one char in the word array via the index variable and thus concludes that the end of a word has been reached via the newline signifier. At this point the word array has the end of string character \0 added, word count is incremented. At this point it calls the misspell function (check); if it is misspelled then the misspell variable is cremented.  The thing this portion does is set index back to zero to setup for the next word. In the final if statement there are usage checks before and after misspell check that update the time_check variable to track time of misspell check. 
5.  If fscanf was used, it would then be necessary to iterate over the scanned data to do validations.  This seems like it would introduce additional complexity and run time by having to relook at the chars again.  It is faster to do the checks as you go.
6.  So they cannot be modified by the functions.
